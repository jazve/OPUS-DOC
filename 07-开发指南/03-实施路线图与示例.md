# 实施路线图与示例

## 🎯 总体实施策略

### 实施原则
- **渐进式开发**：分阶段实施，每阶段都能独立交付价值
- **MVP优先**：优先构建最小可行产品，快速验证核心功能
- **用户驱动**：以用户需求为导向，持续迭代改进
- **技术稳健**：确保技术架构的可扩展性和稳定性

### 实施时间线
```mermaid
gantt
    title OPUS智能体产品实施路线图
    dateFormat  YYYY-MM-DD
    section 阶段一：MVP基础
    需求分析和技术调研    :done, a1, 2024-01-01, 2024-01-15
    核心架构设计         :done, a2, 2024-01-16, 2024-01-31
    OPUS解析器开发       :active, a3, 2024-02-01, 2024-02-28
    基础代码生成器       :a4, 2024-03-01, 2024-03-31
    
    section 阶段二：核心功能
    智能体管理系统       :b1, 2024-04-01, 2024-04-30
    运行时引擎开发       :b2, 2024-05-01, 2024-05-31
    Web控制台基础版      :b3, 2024-06-01, 2024-06-30
    API网关和认证        :b4, 2024-07-01, 2024-07-31
    
    section 阶段三：高级功能
    可视化构建器         :c1, 2024-08-01, 2024-08-31
    模板市场开发         :c2, 2024-09-01, 2024-09-30
    部署管理系统         :c3, 2024-10-01, 2024-10-31
    监控分析平台         :c4, 2024-11-01, 2024-11-30
    
    section 阶段四：企业功能
    协作平台开发         :d1, 2024-12-01, 2024-12-31
    移动端应用           :d2, 2025-01-01, 2025-01-31
    企业级部署方案       :d3, 2025-02-01, 2025-02-28
    AI增强功能           :d4, 2025-03-01, 2025-03-31
```

## 🚀 阶段一：MVP基础版本

### 目标与范围
**目标**：构建能够将OPUS提示词转换为可执行代码的基础系统

**核心功能**：
- OPUS语法解析器
- 基础代码生成器
- 简单的运行时环境
- 命令行工具

### 技术实现示例

#### 1. OPUS解析器MVP
```python
# opus_parser_mvp.py
import re
import json
from typing import Dict, Any, List
from dataclasses import dataclass

@dataclass
class OpusComponent:
    type: str
    content: str
    raw_text: str

class OpusParserMVP:
    """OPUS解析器MVP版本"""
    
    def __init__(self):
        self.component_patterns = {
            'identity': r'<identity>(.*?)</identity>',
            'architecture': r'<architecture>(.*?)</architecture>',
            'memory': r'<Memory>(.*?)</Memory>',
            'formats': r'<formats>(.*?)</formats>',
            'workflow': r'<workflow>(.*?)</workflow>',
            'constraints': r'<constraints>(.*?)</constraints>'
        }
    
    def parse(self, opus_content: str) -> Dict[str, OpusComponent]:
        """解析OPUS内容"""
        components = {}
        
        for component_type, pattern in self.component_patterns.items():
            match = re.search(pattern, opus_content, re.DOTALL | re.IGNORECASE)
            if match:
                components[component_type] = OpusComponent(
                    type=component_type,
                    content=match.group(1).strip(),
                    raw_text=match.group(0)
                )
        
        return components
    
    def extract_functions(self, workflow_content: str) -> List[Dict[str, Any]]:
        """提取工作流函数"""
        function_pattern = r'FN\s+(\w+)\((.*?)\):\s*BEGIN(.*?)END'
        functions = []
        
        for match in re.finditer(function_pattern, workflow_content, re.DOTALL):
            functions.append({
                'name': match.group(1),
                'parameters': match.group(2).strip(),
                'body': match.group(3).strip()
            })
        
        return functions
    
    def extract_formats(self, formats_content: str) -> Dict[str, str]:
        """提取格式定义"""
        format_pattern = r'\[Format\.(\w+)\]\s*=\s*(.*?)(?=\[Format\.|$)'
        formats = {}
        
        for match in re.finditer(format_pattern, formats_content, re.DOTALL):
            formats[match.group(1)] = match.group(2).strip()
        
        return formats

# 使用示例
if __name__ == "__main__":
    parser = OpusParserMVP()
    
    with open("sample_agent.opus", "r", encoding="utf-8") as f:
        opus_content = f.read()
    
    components = parser.parse(opus_content)
    print(f"解析出 {len(components)} 个组件")
    
    for comp_type, component in components.items():
        print(f"\n{comp_type.upper()}:")
        print(component.content[:200] + "...")
```

#### 2. 基础代码生成器
```python
# code_generator_mvp.py
from jinja2 import Template
from typing import Dict, Any
import os

class CodeGeneratorMVP:
    """基础代码生成器"""
    
    def __init__(self):
        self.templates = self._load_templates()
    
    def _load_templates(self) -> Dict[str, Template]:
        """加载代码模板"""
        agent_template = """
# -*- coding: utf-8 -*-
\"\"\"
Generated Agent: {{ agent_name }}
Created by OPUS Code Generator MVP
\"\"\"

import json
from typing import Dict, Any, Optional
from datetime import datetime

class {{ agent_class_name }}:
    \"\"\"{{ agent_description }}\"\"\"
    
    def __init__(self):
        self.identity = {{ identity | tojson }}
        self.memory = {}
        self.formats = {{ formats | tojson }}
        
    def process_request(self, user_input: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        \"\"\"处理用户请求\"\"\"
        try:
            # 基础请求处理逻辑
            response = self._execute_workflow(user_input, context or {})
            
            # 格式化响应
            formatted_response = self._format_response(response)
            
            return {
                "success": True,
                "response": formatted_response,
                "timestamp": datetime.utcnow().isoformat()
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    
    def _execute_workflow(self, user_input: str, context: Dict[str, Any]) -> str:
        \"\"\"执行工作流\"\"\"
        # 简化的工作流执行
        {% for function in functions %}
        # {{ function.name }}: {{ function.parameters }}
        {% endfor %}
        
        return f"处理了请求: {user_input}"
    
    def _format_response(self, response: str) -> str:
        \"\"\"格式化响应\"\"\"
        # 使用预定义格式
        if "默认" in self.formats:
            return self.formats["默认"].replace("{{content}}", response)
        return response
    
    {% for function in functions %}
    def {{ function.name | lower }}(self{% if function.parameters %}, {{ function.parameters }}{% endif %}):
        \"\"\"{{ function.name }}函数\"\"\"
        # TODO: 实现{{ function.name }}逻辑
        # {{ function.body | replace("\\n", "\\n        # ") }}
        pass
    {% endfor %}

if __name__ == "__main__":
    agent = {{ agent_class_name }}()
    
    # 测试运行
    test_input = "你好，我需要帮助"
    result = agent.process_request(test_input)
    print(json.dumps(result, ensure_ascii=False, indent=2))
"""
        
        return {
            "agent": Template(agent_template)
        }
    
    def generate_agent_code(self, components: Dict[str, Any]) -> str:
        """生成智能体代码"""
        # 提取组件信息
        identity = self._parse_identity(components.get('identity', ''))
        functions = self._parse_functions(components.get('workflow', ''))
        formats = self._parse_formats(components.get('formats', ''))
        
        # 生成类名
        agent_name = identity.get('name', 'UnknownAgent')
        agent_class_name = self._to_class_name(agent_name)
        
        # 渲染模板
        template = self.templates['agent']
        code = template.render(
            agent_name=agent_name,
            agent_class_name=agent_class_name,
            agent_description=identity.get('description', '智能体'),
            identity=identity,
            functions=functions,
            formats=formats
        )
        
        return code
    
    def _parse_identity(self, identity_content: str) -> Dict[str, Any]:
        """解析身份信息"""
        # 简化的身份解析
        lines = identity_content.split('\\n')
        identity = {
            'name': 'Agent',
            'description': '智能体',
            'capabilities': []
        }
        
        for line in lines:
            if '你是' in line:
                identity['name'] = line.split('你是')[1].split('，')[0].strip()
            elif '核心能力' in line:
                identity['description'] = line.strip()
        
        return identity
    
    def _parse_functions(self, workflow_content: str) -> List[Dict[str, Any]]:
        """解析函数定义"""
        # 使用之前解析器的函数提取逻辑
        parser = OpusParserMVP()
        return parser.extract_functions(workflow_content)
    
    def _parse_formats(self, formats_content: str) -> Dict[str, str]:
        """解析格式定义"""
        parser = OpusParserMVP()
        return parser.extract_formats(formats_content)
    
    def _to_class_name(self, name: str) -> str:
        """转换为类名格式"""
        # 移除特殊字符，转换为驼峰命名
        clean_name = ''.join(c for c in name if c.isalnum() or c in '_ ')
        words = clean_name.split()
        return ''.join(word.capitalize() for word in words) + 'Agent'

# CLI工具
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 3:
        print("用法: python code_generator_mvp.py <opus_file> <output_file>")
        sys.exit(1)
    
    opus_file = sys.argv[1]
    output_file = sys.argv[2]
    
    # 解析OPUS文件
    parser = OpusParserMVP()
    with open(opus_file, 'r', encoding='utf-8') as f:
        opus_content = f.read()
    
    components = parser.parse(opus_content)
    
    # 生成代码
    generator = CodeGeneratorMVP()
    code = generator.generate_agent_code(components)
    
    # 保存代码
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(code)
    
    print(f"代码已生成到: {output_file}")
```

#### 3. 简单运行时环境
```python
# agent_runtime_mvp.py
import json
import logging
from typing import Dict, Any, Optional
from datetime import datetime

class AgentRuntimeMVP:
    """简单的智能体运行时环境"""
    
    def __init__(self, agent_module):
        self.agent = agent_module
        self.session_data = {}
        self.logger = self._setup_logger()
    
    def _setup_logger(self):
        """设置日志"""
        logger = logging.getLogger('agent_runtime')
        logger.setLevel(logging.INFO)
        
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger
    
    def start_session(self, session_id: str) -> Dict[str, Any]:
        """启动会话"""
        self.session_data[session_id] = {
            'created_at': datetime.utcnow().isoformat(),
            'messages': [],
            'context': {}
        }
        
        self.logger.info(f"会话 {session_id} 已启动")
        
        return {
            'session_id': session_id,
            'status': 'active',
            'message': '会话已启动'
        }
    
    def process_message(self, session_id: str, message: str) -> Dict[str, Any]:
        """处理消息"""
        if session_id not in self.session_data:
            return {
                'error': f'会话 {session_id} 不存在',
                'timestamp': datetime.utcnow().isoformat()
            }
        
        session = self.session_data[session_id]
        
        try:
            # 记录用户消息
            session['messages'].append({
                'type': 'user',
                'content': message,
                'timestamp': datetime.utcnow().isoformat()
            })
            
            # 调用智能体处理
            result = self.agent.process_request(message, session['context'])
            
            # 记录智能体响应
            session['messages'].append({
                'type': 'agent',
                'content': result.get('response', ''),
                'timestamp': datetime.utcnow().isoformat()
            })
            
            self.logger.info(f"会话 {session_id} 处理消息: {message[:50]}...")
            
            return result
            
        except Exception as e:
            self.logger.error(f"处理消息时出错: {e}")
            return {
                'success': False,
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat()
            }
    
    def get_session_history(self, session_id: str) -> Dict[str, Any]:
        """获取会话历史"""
        if session_id not in self.session_data:
            return {'error': f'会话 {session_id} 不存在'}
        
        return self.session_data[session_id]
    
    def end_session(self, session_id: str) -> Dict[str, Any]:
        """结束会话"""
        if session_id in self.session_data:
            del self.session_data[session_id]
            self.logger.info(f"会话 {session_id} 已结束")
            return {'message': '会话已结束'}
        
        return {'error': f'会话 {session_id} 不存在'}

# 命令行交互工具
class CLIInterface:
    """命令行交互界面"""
    
    def __init__(self, agent_file: str):
        # 动态导入生成的智能体
        import importlib.util
        spec = importlib.util.spec_from_file_location("agent_module", agent_file)
        agent_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(agent_module)
        
        # 获取智能体类
        agent_class = None
        for attr_name in dir(agent_module):
            attr = getattr(agent_module, attr_name)
            if isinstance(attr, type) and attr_name.endswith('Agent'):
                agent_class = attr
                break
        
        if not agent_class:
            raise ValueError("未找到智能体类")
        
        self.agent = agent_class()
        self.runtime = AgentRuntimeMVP(self.agent)
        self.session_id = f"cli_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
    
    def run(self):
        """运行CLI界面"""
        print("🤖 OPUS智能体 CLI - MVP版本")
        print("=" * 50)
        print("输入 '/help' 查看帮助，输入 '/quit' 退出")
        print()
        
        # 启动会话
        self.runtime.start_session(self.session_id)
        
        while True:
            try:
                user_input = input("👤 用户: ").strip()
                
                if user_input == '/quit':
                    break
                elif user_input == '/help':
                    self._show_help()
                    continue
                elif user_input == '/history':
                    self._show_history()
                    continue
                elif user_input == '':
                    continue
                
                # 处理用户输入
                result = self.runtime.process_message(self.session_id, user_input)
                
                if result.get('success', True):
                    print(f"🤖 智能体: {result.get('response', '无响应')}")
                else:
                    print(f"❌ 错误: {result.get('error', '未知错误')}")
                
                print()
                
            except KeyboardInterrupt:
                print("\\n程序被用户中断")
                break
            except Exception as e:
                print(f"❌ 系统错误: {e}")
        
        # 结束会话
        self.runtime.end_session(self.session_id)
        print("👋 再见！")
    
    def _show_help(self):
        """显示帮助信息"""
        print("📖 帮助信息:")
        print("  /help    - 显示此帮助信息")
        print("  /history - 显示对话历史")
        print("  /quit    - 退出程序")
        print()
    
    def _show_history(self):
        """显示对话历史"""
        history = self.runtime.get_session_history(self.session_id)
        messages = history.get('messages', [])
        
        print("📜 对话历史:")
        for i, msg in enumerate(messages, 1):
            icon = "👤" if msg['type'] == 'user' else "🤖"
            print(f"  {i}. {icon} {msg['content']}")
        print()

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 2:
        print("用法: python agent_runtime_mvp.py <agent_file.py>")
        sys.exit(1)
    
    agent_file = sys.argv[1]
    
    try:
        cli = CLIInterface(agent_file)
        cli.run()
    except Exception as e:
        print(f"启动失败: {e}")
```

#### 4. 简单Web界面
```python
# web_interface_mvp.py
from flask import Flask, render_template, request, jsonify, session
import uuid
from datetime import datetime
import importlib.util
import os

app = Flask(__name__)
app.secret_key = 'your-secret-key-here'

class WebInterfaceMVP:
    """简单Web界面"""
    
    def __init__(self):
        self.runtimes = {}  # 存储不同用户的运行时
    
    def load_agent(self, agent_file: str):
        """加载智能体"""
        spec = importlib.util.spec_from_file_location("agent_module", agent_file)
        agent_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(agent_module)
        
        # 获取智能体类
        for attr_name in dir(agent_module):
            attr = getattr(agent_module, attr_name)
            if isinstance(attr, type) and attr_name.endswith('Agent'):
                return attr()
        
        raise ValueError("未找到智能体类")
    
    def get_or_create_runtime(self, session_id: str):
        """获取或创建运行时"""
        if session_id not in self.runtimes:
            agent_file = os.environ.get('AGENT_FILE', 'generated_agent.py')
            agent = self.load_agent(agent_file)
            self.runtimes[session_id] = AgentRuntimeMVP(agent)
            self.runtimes[session_id].start_session(session_id)
        
        return self.runtimes[session_id]

web_interface = WebInterfaceMVP()

@app.route('/')
def index():
    """主页"""
    if 'session_id' not in session:
        session['session_id'] = str(uuid.uuid4())
    
    return render_template('chat.html')

@app.route('/api/chat', methods=['POST'])
def chat():
    """聊天API"""
    data = request.get_json()
    message = data.get('message', '')
    
    if not message:
        return jsonify({'error': '消息不能为空'}), 400
    
    session_id = session.get('session_id')
    if not session_id:
        return jsonify({'error': '会话无效'}), 400
    
    try:
        runtime = web_interface.get_or_create_runtime(session_id)
        result = runtime.process_message(session_id, message)
        return jsonify(result)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/history')
def history():
    """获取历史"""
    session_id = session.get('session_id')
    if not session_id:
        return jsonify({'error': '会话无效'}), 400
    
    try:
        runtime = web_interface.get_or_create_runtime(session_id)
        history = runtime.get_session_history(session_id)
        return jsonify(history)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# HTML模板
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPUS智能体 - MVP版本</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f7fa;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        .chat-container {
            height: 500px;
            overflow-y: auto;
            padding: 20px;
            border-bottom: 1px solid #eee;
        }
        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
        }
        .message.user {
            justify-content: flex-end;
        }
        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
        }
        .message.user .message-content {
            background: #007AFF;
            color: white;
        }
        .message.agent .message-content {
            background: #f1f3f5;
            color: #333;
        }
        .input-container {
            padding: 20px;
            display: flex;
            gap: 10px;
        }
        .input-container input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
            font-size: 14px;
        }
        .input-container button {
            padding: 12px 24px;
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
        }
        .input-container button:hover {
            background: #0056CC;
        }
        .input-container button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 OPUS智能体</h1>
            <p>MVP演示版本</p>
        </div>
        <div id="chatContainer" class="chat-container">
            <!-- 消息将在这里显示 -->
        </div>
        <div class="input-container">
            <input type="text" id="messageInput" placeholder="输入您的消息..." onkeypress="handleKeyPress(event)">
            <button id="sendButton" onclick="sendMessage()">发送</button>
        </div>
    </div>

    <script>
        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');

        // 添加消息到聊天界面
        function addMessage(type, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = content;
            
            messageDiv.appendChild(contentDiv);
            chatContainer.appendChild(messageDiv);
            
            // 滚动到底部
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // 发送消息
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            // 显示用户消息
            addMessage('user', message);
            messageInput.value = '';
            
            // 禁用发送按钮
            sendButton.disabled = true;
            sendButton.textContent = '发送中...';

            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ message })
                });

                const data = await response.json();

                if (data.success !== false) {
                    addMessage('agent', data.response || '无响应');
                } else {
                    addMessage('agent', `错误: ${data.error}`);
                }
            } catch (error) {
                addMessage('agent', `网络错误: ${error.message}`);
            } finally {
                // 恢复发送按钮
                sendButton.disabled = false;
                sendButton.textContent = '发送';
                messageInput.focus();
            }
        }

        // 处理回车键
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // 页面加载完成后聚焦输入框
        window.addEventListener('load', () => {
            messageInput.focus();
            addMessage('agent', '你好！我是OPUS智能体，有什么可以帮助您的吗？');
        });
    </script>
</body>
</html>
'''

# 创建模板目录和文件
if not os.path.exists('templates'):
    os.makedirs('templates')

with open('templates/chat.html', 'w', encoding='utf-8') as f:
    f.write(HTML_TEMPLATE)

if __name__ == '__main__':
    import sys
    
    if len(sys.argv) > 1:
        os.environ['AGENT_FILE'] = sys.argv[1]
    
    print("🚀 启动OPUS智能体Web界面...")
    print("访问 http://localhost:5000 开始使用")
    
    app.run(debug=True, host='0.0.0.0', port=5000)
```

### MVP部署脚本
```bash
#!/bin/bash
# deploy_mvp.sh

echo "🚀 部署OPUS智能体MVP版本"

# 1. 创建项目目录
mkdir -p opus-mvp
cd opus-mvp

# 2. 创建虚拟环境
python3 -m venv venv
source venv/bin/activate

# 3. 安装依赖
pip install flask jinja2

# 4. 复制代码文件
# (假设代码文件已经存在)

# 5. 创建示例OPUS文件
cat > sample_agent.opus << 'EOF'
<identity>
你是代码审查助手，专门帮助开发者进行代码质量检查和改进建议。
核心能力：代码分析、质量评估、改进建议、最佳实践推荐
语气风格：专业严谨、建设性、友好指导
</identity>

<architecture>
专业知识：[软件工程,代码质量,设计模式,最佳实践]
核心技能：[代码分析,问题识别,改进建议,文档生成]
推理引擎：[逻辑分析,模式识别,质量评估]
</architecture>

<Memory>
记忆系统：代码审查历史和模式库
操作：[Memory.Store,Memory.Retrieve,Memory.Analyze]
</Memory>

<formats>
[Format.分析] = 📋 **代码分析结果**
- 🎯 **质量评分**：{{quality_score}}/10
- ⚠️ **问题数量**：{{issue_count}}
- 💡 **改进建议**：{{suggestions}}

[Format.建议] = 💡 **改进建议**
{{suggestion_details}}
</formats>

<workflow>
FN 审查代码(code_content):
BEGIN
  分析代码结构和质量
  识别潜在问题
  生成改进建议
  输出格式化结果
END

FN 提供建议(issue_type):
BEGIN
  根据问题类型给出具体建议
  包含代码示例
  解释改进理由
END
</workflow>

<constraints>
**行为约束**：
- 保持专业和建设性的审查态度
- 提供具体可行的改进建议
- 关注代码质量和最佳实践

**技术约束**：
- 支持主流编程语言
- 遵循行业标准和规范
</constraints>
EOF

# 6. 生成智能体代码
echo "📝 生成智能体代码..."
python code_generator_mvp.py sample_agent.opus generated_agent.py

# 7. 测试CLI界面
echo "🧪 测试CLI界面..."
echo "你好，帮我审查一段Python代码" | python agent_runtime_mvp.py generated_agent.py

# 8. 启动Web界面
echo "🌐 启动Web界面..."
python web_interface_mvp.py generated_agent.py &

echo "✅ MVP部署完成！"
echo "🌐 Web界面: http://localhost:5000"
echo "💻 CLI测试: python agent_runtime_mvp.py generated_agent.py"
```

## 🔄 阶段二：核心功能开发

### 目标与范围
**目标**：构建完整的智能体管理和运行系统

**核心功能**：
- 智能体管理Web界面
- 多用户支持和权限管理
- RESTful API
- 数据持久化
- 基础监控

### 实现示例

#### 1. Web管理界面架构
```typescript
// frontend/src/types/agent.ts
export interface Agent {
  id: string;
  name: string;
  description: string;
  opusCode: string;
  ownerId: string;
  status: 'draft' | 'active' | 'inactive';
  createdAt: string;
  updatedAt: string;
  metrics?: AgentMetrics;
}

export interface AgentMetrics {
  requestCount: number;
  avgResponseTime: number;
  errorRate: number;
  lastActiveAt: string;
}

// frontend/src/components/AgentManager.tsx
import React, { useState, useEffect } from 'react';
import { Agent } from '../types/agent';
import { agentService } from '../services/agentService';

export const AgentManager: React.FC = () => {
  const [agents, setAgents] = useState<Agent[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedAgent, setSelectedAgent] = useState<Agent | null>(null);

  useEffect(() => {
    loadAgents();
  }, []);

  const loadAgents = async () => {
    try {
      const agentList = await agentService.listAgents();
      setAgents(agentList);
    } catch (error) {
      console.error('加载智能体失败:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleCreateAgent = async (agentData: Partial<Agent>) => {
    try {
      const newAgent = await agentService.createAgent(agentData);
      setAgents([...agents, newAgent]);
    } catch (error) {
      console.error('创建智能体失败:', error);
    }
  };

  const handleDeleteAgent = async (agentId: string) => {
    try {
      await agentService.deleteAgent(agentId);
      setAgents(agents.filter(agent => agent.id !== agentId));
    } catch (error) {
      console.error('删除智能体失败:', error);
    }
  };

  if (loading) {
    return <div className="loading">加载中...</div>;
  }

  return (
    <div className="agent-manager">
      <div className="agent-list">
        <h2>智能体列表</h2>
        <button 
          className="create-btn"
          onClick={() => setSelectedAgent({} as Agent)}
        >
          创建新智能体
        </button>
        
        {agents.map(agent => (
          <div key={agent.id} className="agent-card">
            <h3>{agent.name}</h3>
            <p>{agent.description}</p>
            <div className="agent-status">
              状态: {agent.status}
            </div>
            <div className="agent-actions">
              <button onClick={() => setSelectedAgent(agent)}>编辑</button>
              <button onClick={() => handleDeleteAgent(agent.id)}>删除</button>
            </div>
          </div>
        ))}
      </div>
      
      {selectedAgent && (
        <AgentEditor
          agent={selectedAgent}
          onSave={handleCreateAgent}
          onCancel={() => setSelectedAgent(null)}
        />
      )}
    </div>
  );
};
```

#### 2. 后端API服务
```python
# backend/app/main.py
from fastapi import FastAPI, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from typing import List

from .database import get_db
from .models import Agent as AgentModel
from .schemas import Agent, AgentCreate, AgentUpdate
from .services.agent_service import AgentService
from .auth import get_current_user

app = FastAPI(title="OPUS Agent Platform", version="2.0.0")

# CORS配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # 前端地址
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

agent_service = AgentService()

@app.get("/api/agents", response_model=List[Agent])
async def list_agents(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """获取智能体列表"""
    agents = agent_service.get_user_agents(db, current_user.id, skip, limit)
    return agents

@app.post("/api/agents", response_model=Agent)
async def create_agent(
    agent: AgentCreate,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """创建智能体"""
    return agent_service.create_agent(db, agent, current_user.id)

@app.get("/api/agents/{agent_id}", response_model=Agent)
async def get_agent(
    agent_id: str,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """获取智能体详情"""
    agent = agent_service.get_agent(db, agent_id)
    if not agent or agent.owner_id != current_user.id:
        raise HTTPException(status_code=404, detail="智能体不存在")
    return agent

@app.put("/api/agents/{agent_id}", response_model=Agent)
async def update_agent(
    agent_id: str,
    agent_update: AgentUpdate,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """更新智能体"""
    agent = agent_service.get_agent(db, agent_id)
    if not agent or agent.owner_id != current_user.id:
        raise HTTPException(status_code=404, detail="智能体不存在")
    
    return agent_service.update_agent(db, agent_id, agent_update)

@app.delete("/api/agents/{agent_id}")
async def delete_agent(
    agent_id: str,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """删除智能体"""
    agent = agent_service.get_agent(db, agent_id)
    if not agent or agent.owner_id != current_user.id:
        raise HTTPException(status_code=404, detail="智能体不存在")
    
    agent_service.delete_agent(db, agent_id)
    return {"message": "智能体已删除"}

@app.post("/api/agents/{agent_id}/chat")
async def chat_with_agent(
    agent_id: str,
    message: dict,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """与智能体对话"""
    agent = agent_service.get_agent(db, agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail="智能体不存在")
    
    # 检查权限（所有者或有权限的用户）
    if not agent_service.can_access_agent(agent, current_user.id):
        raise HTTPException(status_code=403, detail="无权限访问此智能体")
    
    # 处理对话
    response = await agent_service.process_chat(agent_id, message, current_user.id)
    return response
```

#### 3. 数据模型设计
```python
# backend/app/models.py
from sqlalchemy import Column, String, Text, DateTime, Integer, ForeignKey, Enum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime
import enum

Base = declarative_base()

class AgentStatus(enum.Enum):
    DRAFT = "draft"
    ACTIVE = "active"
    INACTIVE = "inactive"

class Agent(Base):
    __tablename__ = "agents"
    
    id = Column(String, primary_key=True)
    name = Column(String(100), nullable=False)
    description = Column(Text)
    opus_code = Column(Text, nullable=False)
    owner_id = Column(String, ForeignKey("users.id"), nullable=False)
    status = Column(Enum(AgentStatus), default=AgentStatus.DRAFT)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 关系
    owner = relationship("User", back_populates="agents")
    conversations = relationship("Conversation", back_populates="agent")
    metrics = relationship("AgentMetrics", back_populates="agent", uselist=False)

class User(Base):
    __tablename__ = "users"
    
    id = Column(String, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # 关系
    agents = relationship("Agent", back_populates="owner")

class Conversation(Base):
    __tablename__ = "conversations"
    
    id = Column(String, primary_key=True)
    agent_id = Column(String, ForeignKey("agents.id"), nullable=False)
    user_id = Column(String, ForeignKey("users.id"), nullable=False)
    session_id = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # 关系
    agent = relationship("Agent", back_populates="conversations")
    messages = relationship("Message", back_populates="conversation")

class Message(Base):
    __tablename__ = "messages"
    
    id = Column(String, primary_key=True)
    conversation_id = Column(String, ForeignKey("conversations.id"), nullable=False)
    role = Column(String(10), nullable=False)  # 'user' or 'agent'
    content = Column(Text, nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow)
    
    # 关系
    conversation = relationship("Conversation", back_populates="messages")

class AgentMetrics(Base):
    __tablename__ = "agent_metrics"
    
    id = Column(String, primary_key=True)
    agent_id = Column(String, ForeignKey("agents.id"), nullable=False)
    request_count = Column(Integer, default=0)
    avg_response_time = Column(Integer, default=0)  # 毫秒
    error_rate = Column(Integer, default=0)  # 百分比
    last_active_at = Column(DateTime)
    
    # 关系
    agent = relationship("Agent", back_populates="metrics")
```

### 阶段二部署脚本
```bash
#!/bin/bash
# deploy_stage2.sh

echo "🚀 部署OPUS智能体平台 - 阶段二"

# 1. 检查环境
command -v docker >/dev/null 2>&1 || { echo "需要安装Docker"; exit 1; }
command -v docker-compose >/dev/null 2>&1 || { echo "需要安装Docker Compose"; exit 1; }
command -v node >/dev/null 2>&1 || { echo "需要安装Node.js"; exit 1; }

# 2. 创建项目结构
mkdir -p opus-platform/{backend,frontend,database,docker}
cd opus-platform

# 3. 创建Docker Compose配置
cat > docker-compose.yml << 'EOF'
version: '3.8'

services:
  database:
    image: postgres:14
    environment:
      POSTGRES_DB: opus_platform
      POSTGRES_USER: opus_user
      POSTGRES_PASSWORD: opus_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7
    ports:
      - "6379:6379"

  backend:
    build: ./backend
    environment:
      DATABASE_URL: postgresql://opus_user:opus_password@database:5432/opus_platform
      REDIS_URL: redis://redis:6379/0
      SECRET_KEY: your-secret-key-here
    ports:
      - "8000:8000"
    depends_on:
      - database
      - redis
    volumes:
      - ./backend:/app

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      REACT_APP_API_URL: http://localhost:8000
    volumes:
      - ./frontend:/app
    depends_on:
      - backend

volumes:
  postgres_data:
EOF

# 4. 创建后端Dockerfile
cat > backend/Dockerfile << 'EOF'
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
EOF

# 5. 创建前端Dockerfile
cat > frontend/Dockerfile << 'EOF'
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

CMD ["npm", "start"]
EOF

# 6. 创建后端依赖文件
cat > backend/requirements.txt << 'EOF'
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
psycopg2-binary==2.9.9
alembic==1.12.1
redis==5.0.1
python-jose==3.3.0
passlib==1.7.4
python-multipart==0.0.6
pydantic==2.5.0
jinja2==3.1.2
EOF

# 7. 初始化前端项目（如果需要）
if [ ! -f "frontend/package.json" ]; then
    cd frontend
    npx create-react-app . --template typescript
    npm install axios @types/axios
    cd ..
fi

# 8. 启动服务
echo "🐳 启动Docker服务..."
docker-compose up -d database redis

echo "⏳ 等待数据库启动..."
sleep 10

echo "🗄️ 初始化数据库..."
docker-compose run --rm backend alembic upgrade head

echo "🚀 启动所有服务..."
docker-compose up -d

echo "✅ 阶段二部署完成！"
echo "🌐 前端界面: http://localhost:3000"
echo "🔧 后端API: http://localhost:8000"
echo "📖 API文档: http://localhost:8000/docs"
echo ""
echo "📊 服务状态:"
docker-compose ps
EOF
```

## 📈 阶段三：高级功能

### 可视化构建器实现
```typescript
// frontend/src/components/VisualBuilder/OpusBuilder.tsx
import React, { useState, useCallback } from 'react';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { ComponentPalette } from './ComponentPalette';
import { BuilderCanvas } from './BuilderCanvas';
import { PropertyPanel } from './PropertyPanel';
import { CodePreview } from './CodePreview';

interface OpusComponent {
  id: string;
  type: 'identity' | 'architecture' | 'memory' | 'formats' | 'workflow' | 'constraints';
  position: { x: number; y: number };
  properties: Record<string, any>;
  connections: string[];
}

export const OpusBuilder: React.FC = () => {
  const [components, setComponents] = useState<OpusComponent[]>([]);
  const [selectedComponent, setSelectedComponent] = useState<OpusComponent | null>(null);
  const [generatedCode, setGeneratedCode] = useState<string>('');

  const handleAddComponent = useCallback((componentType: string, position: { x: number; y: number }) => {
    const newComponent: OpusComponent = {
      id: `${componentType}_${Date.now()}`,
      type: componentType as any,
      position,
      properties: getDefaultProperties(componentType),
      connections: []
    };
    
    setComponents(prev => [...prev, newComponent]);
  }, []);

  const handleUpdateComponent = useCallback((componentId: string, updates: Partial<OpusComponent>) => {
    setComponents(prev => prev.map(comp => 
      comp.id === componentId ? { ...comp, ...updates } : comp
    ));
  }, []);

  const handleGenerateCode = useCallback(async () => {
    try {
      const response = await fetch('/api/generate-opus', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ components })
      });
      
      const data = await response.json();
      setGeneratedCode(data.opusCode);
    } catch (error) {
      console.error('生成代码失败:', error);
    }
  }, [components]);

  return (
    <DndProvider backend={HTML5Backend}>
      <div className="opus-builder">
        <div className="builder-layout">
          <div className="left-panel">
            <ComponentPalette />
          </div>
          
          <div className="center-panel">
            <BuilderCanvas
              components={components}
              onAddComponent={handleAddComponent}
              onSelectComponent={setSelectedComponent}
              onUpdateComponent={handleUpdateComponent}
            />
          </div>
          
          <div className="right-panel">
            <PropertyPanel
              selectedComponent={selectedComponent}
              onUpdateComponent={handleUpdateComponent}
            />
            
            <CodePreview
              code={generatedCode}
              onGenerate={handleGenerateCode}
            />
          </div>
        </div>
      </div>
    </DndProvider>
  );
};

function getDefaultProperties(componentType: string): Record<string, any> {
  const defaults = {
    identity: {
      name: '新智能体',
      description: '智能体描述',
      capabilities: [],
      tone: 'professional'
    },
    architecture: {
      knowledge: [],
      skills: [],
      tools: [],
      rag: false
    },
    memory: {
      structure: 'hierarchical',
      operations: ['store', 'retrieve'],
      persistence: true
    },
    formats: {
      templates: []
    },
    workflow: {
      functions: []
    },
    constraints: {
      behavioral: [],
      technical: [],
      content: []
    }
  };
  
  return defaults[componentType] || {};
}
```

### 模板市场实现
```python
# backend/app/services/marketplace_service.py
from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func
from ..models import AgentTemplate, User, TemplateReview
from ..schemas import TemplateCreate, TemplateSearch, TemplateStats

class MarketplaceService:
    """模板市场服务"""
    
    def __init__(self):
        self.search_engine = TemplateSearchEngine()
        self.recommendation_engine = RecommendationEngine()
    
    def publish_template(self, db: Session, template_data: TemplateCreate, user_id: str) -> AgentTemplate:
        """发布模板"""
        # 1. 安全检查
        security_result = self.security_scanner.scan_template(template_data.opus_code)
        if not security_result.is_safe:
            raise SecurityException("模板包含安全风险")
        
        # 2. 质量检查
        quality_score = self.quality_analyzer.analyze(template_data.opus_code)
        if quality_score < 0.7:
            raise QualityException("模板质量不符合发布标准")
        
        # 3. 创建模板
        template = AgentTemplate(
            id=generate_id(),
            name=template_data.name,
            description=template_data.description,
            category=template_data.category,
            opus_code=template_data.opus_code,
            creator_id=user_id,
            price=template_data.price,
            license=template_data.license,
            quality_score=quality_score,
            status="published"
        )
        
        db.add(template)
        db.commit()
        
        # 4. 建立搜索索引
        self.search_engine.index_template(template)
        
        return template
    
    def search_templates(self, db: Session, search_query: TemplateSearch) -> List[AgentTemplate]:
        """搜索模板"""
        query = db.query(AgentTemplate).filter(
            AgentTemplate.status == "published"
        )
        
        # 文本搜索
        if search_query.text:
            search_terms = search_query.text.split()
            text_filter = or_(*[
                or_(
                    AgentTemplate.name.ilike(f"%{term}%"),
                    AgentTemplate.description.ilike(f"%{term}%"),
                    AgentTemplate.tags.contains([term])
                ) for term in search_terms
            ])
            query = query.filter(text_filter)
        
        # 分类过滤
        if search_query.category:
            query = query.filter(AgentTemplate.category == search_query.category)
        
        # 价格范围
        if search_query.min_price is not None:
            query = query.filter(AgentTemplate.price >= search_query.min_price)
        if search_query.max_price is not None:
            query = query.filter(AgentTemplate.price <= search_query.max_price)
        
        # 评分过滤
        if search_query.min_rating:
            query = query.filter(AgentTemplate.rating >= search_query.min_rating)
        
        # 排序
        if search_query.sort_by == "popularity":
            query = query.order_by(AgentTemplate.downloads.desc())
        elif search_query.sort_by == "rating":
            query = query.order_by(AgentTemplate.rating.desc())
        elif search_query.sort_by == "newest":
            query = query.order_by(AgentTemplate.created_at.desc())
        elif search_query.sort_by == "price_low":
            query = query.order_by(AgentTemplate.price.asc())
        elif search_query.sort_by == "price_high":
            query = query.order_by(AgentTemplate.price.desc())
        
        # 分页
        offset = (search_query.page - 1) * search_query.page_size
        return query.offset(offset).limit(search_query.page_size).all()
    
    def get_recommendations(self, db: Session, user_id: str) -> List[AgentTemplate]:
        """获取个性化推荐"""
        user_profile = self.build_user_profile(db, user_id)
        return self.recommendation_engine.recommend(db, user_profile)
    
    def download_template(self, db: Session, template_id: str, user_id: str) -> AgentTemplate:
        """下载模板"""
        template = db.query(AgentTemplate).filter(AgentTemplate.id == template_id).first()
        if not template:
            raise NotFoundException("模板不存在")
        
        # 检查购买权限（如果是付费模板）
        if template.price > 0:
            purchase = self.check_purchase(db, template_id, user_id)
            if not purchase:
                raise PermissionException("需要购买此模板")
        
        # 增加下载次数
        template.downloads += 1
        db.commit()
        
        # 记录下载历史
        self.record_download(db, template_id, user_id)
        
        return template
    
    def rate_template(self, db: Session, template_id: str, user_id: str, rating: int, review: str = None) -> None:
        """评价模板"""
        # 检查是否已评价
        existing_review = db.query(TemplateReview).filter(
            and_(
                TemplateReview.template_id == template_id,
                TemplateReview.user_id == user_id
            )
        ).first()
        
        if existing_review:
            # 更新评价
            existing_review.rating = rating
            existing_review.review = review
            existing_review.updated_at = datetime.utcnow()
        else:
            # 新增评价
            new_review = TemplateReview(
                id=generate_id(),
                template_id=template_id,
                user_id=user_id,
                rating=rating,
                review=review
            )
            db.add(new_review)
        
        db.commit()
        
        # 更新模板平均评分
        self.update_template_rating(db, template_id)
    
    def get_template_stats(self, db: Session, template_id: str) -> TemplateStats:
        """获取模板统计"""
        template = db.query(AgentTemplate).filter(AgentTemplate.id == template_id).first()
        if not template:
            raise NotFoundException("模板不存在")
        
        # 计算统计数据
        review_stats = db.query(
            func.count(TemplateReview.id).label('review_count'),
            func.avg(TemplateReview.rating).label('avg_rating'),
            func.max(TemplateReview.created_at).label('latest_review')
        ).filter(TemplateReview.template_id == template_id).first()
        
        return TemplateStats(
            template_id=template_id,
            downloads=template.downloads,
            review_count=review_stats.review_count or 0,
            average_rating=float(review_stats.avg_rating or 0),
            latest_review_date=review_stats.latest_review
        )
```

## 🚀 阶段四：企业级功能

### 协作平台实现
```python
# backend/app/services/collaboration_service.py
from typing import List, Optional
from sqlalchemy.orm import Session
from ..models import Workspace, WorkspaceMember, Agent, ShareLink
from ..schemas import WorkspaceCreate, SharingConfig

class CollaborationService:
    """协作服务"""
    
    def __init__(self):
        self.version_control = VersionControlService()
        self.notification_service = NotificationService()
    
    def create_workspace(self, db: Session, workspace_data: WorkspaceCreate, owner_id: str) -> Workspace:
        """创建工作空间"""
        workspace = Workspace(
            id=generate_id(),
            name=workspace_data.name,
            description=workspace_data.description,
            owner_id=owner_id,
            settings=workspace_data.settings
        )
        
        db.add(workspace)
        
        # 添加所有者为管理员
        owner_member = WorkspaceMember(
            workspace_id=workspace.id,
            user_id=owner_id,
            role="admin",
            permissions=["read", "write", "manage", "share"]
        )
        db.add(owner_member)
        
        db.commit()
        
        # 初始化版本控制
        self.version_control.init_workspace_repo(workspace.id)
        
        return workspace
    
    def invite_member(self, db: Session, workspace_id: str, inviter_id: str, email: str, role: str) -> None:
        """邀请成员"""
        # 检查邀请权限
        if not self.has_permission(db, workspace_id, inviter_id, "manage"):
            raise PermissionException("无权限邀请成员")
        
        # 发送邀请邮件
        invitation_token = generate_invitation_token()
        self.notification_service.send_workspace_invitation(
            email=email,
            workspace_name=self.get_workspace_name(db, workspace_id),
            invitation_url=f"/workspace/join/{invitation_token}",
            inviter_name=self.get_user_name(db, inviter_id)
        )
        
        # 存储邀请记录
        self.store_invitation(db, workspace_id, email, role, invitation_token)
    
    def share_agent(self, db: Session, agent_id: str, user_id: str, config: SharingConfig) -> ShareLink:
        """分享智能体"""
        agent = db.query(Agent).filter(Agent.id == agent_id).first()
        if not agent:
            raise NotFoundException("智能体不存在")
        
        # 检查分享权限
        if not self.can_share_agent(db, agent_id, user_id):
            raise PermissionException("无权限分享此智能体")
        
        # 创建分享链接
        share_link = ShareLink(
            id=generate_id(),
            agent_id=agent_id,
            creator_id=user_id,
            access_token=generate_access_token(),
            permissions=config.permissions,
            expires_at=config.expires_at,
            max_uses=config.max_uses,
            uses_count=0
        )
        
        db.add(share_link)
        db.commit()
        
        return share_link
    
    def fork_agent(self, db: Session, agent_id: str, user_id: str, workspace_id: Optional[str] = None) -> Agent:
        """复制智能体"""
        original_agent = db.query(Agent).filter(Agent.id == agent_id).first()
        if not original_agent:
            raise NotFoundException("智能体不存在")
        
        # 检查访问权限
        if not self.can_access_agent(db, agent_id, user_id):
            raise PermissionException("无权限访问此智能体")
        
        # 创建复制
        forked_agent = Agent(
            id=generate_id(),
            name=f"{original_agent.name} (Fork)",
            description=original_agent.description,
            opus_code=original_agent.opus_code,
            owner_id=user_id,
            workspace_id=workspace_id,
            parent_id=agent_id,
            status="draft"
        )
        
        db.add(forked_agent)
        db.commit()
        
        # 创建版本控制分支
        self.version_control.create_fork(original_agent.id, forked_agent.id)
        
        return forked_agent
    
    def sync_changes(self, db: Session, source_agent_id: str, target_agent_id: str, user_id: str) -> None:
        """同步变更"""
        # 检查权限
        if not self.can_write_agent(db, target_agent_id, user_id):
            raise PermissionException("无权限修改目标智能体")
        
        # 获取变更
        changes = self.version_control.get_changes(source_agent_id, target_agent_id)
        
        if not changes:
            return
        
        # 应用变更
        target_agent = db.query(Agent).filter(Agent.id == target_agent_id).first()
        merged_code = self.version_control.merge_changes(target_agent.opus_code, changes)
        
        target_agent.opus_code = merged_code
        target_agent.updated_at = datetime.utcnow()
        
        db.commit()
        
        # 记录同步历史
        self.record_sync(db, source_agent_id, target_agent_id, user_id)
```

### 移动端核心功能
```typescript
// mobile/src/services/AgentService.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Agent, ChatMessage, OfflineCapability } from '../types';

export class MobileAgentService {
  private apiClient: APIClient;
  private offlineManager: OfflineManager;
  
  constructor() {
    this.apiClient = new APIClient();
    this.offlineManager = new OfflineManager();
  }
  
  async syncAgents(): Promise<Agent[]> {
    try {
      // 在线获取最新智能体列表
      const onlineAgents = await this.apiClient.getAgents();
      
      // 缓存到本地
      await AsyncStorage.setItem('cached_agents', JSON.stringify(onlineAgents));
      
      return onlineAgents;
    } catch (error) {
      // 离线模式：从缓存获取
      const cachedAgents = await AsyncStorage.getItem('cached_agents');
      return cachedAgents ? JSON.parse(cachedAgents) : [];
    }
  }
  
  async chatWithAgent(agentId: string, message: string): Promise<ChatMessage> {
    try {
      // 检查网络状态
      const isOnline = await this.checkNetworkStatus();
      
      if (isOnline) {
        // 在线模式
        return await this.apiClient.chat(agentId, message);
      } else {
        // 离线模式
        return await this.offlineManager.processOfflineChat(agentId, message);
      }
    } catch (error) {
      // 降级到离线处理
      return await this.offlineManager.processOfflineChat(agentId, message);
    }
  }
  
  async enableOfflineAgent(agentId: string): Promise<void> {
    const agent = await this.apiClient.getAgent(agentId);
    
    // 下载智能体数据
    const agentData = {
      ...agent,
      offlineModel: await this.downloadOfflineModel(agent),
      offlineKnowledge: await this.downloadOfflineKnowledge(agent)
    };
    
    // 保存到本地
    await this.offlineManager.storeOfflineAgent(agentData);
  }
  
  async startVoiceChat(agentId: string): Promise<void> {
    const audioRecorder = new AudioRecorder();
    
    // 开始录音
    const audioStream = await audioRecorder.start();
    
    // 语音转文字
    const transcription = await this.speechToText(audioStream);
    
    // 发送消息
    const response = await this.chatWithAgent(agentId, transcription);
    
    // 文字转语音
    await this.textToSpeech(response.content);
  }
  
  async getLocationContext(): Promise<LocationContext> {
    const location = await Geolocation.getCurrentPosition();
    const placeInfo = await this.placesAPI.getPlaceInfo(location);
    
    return {
      coordinates: location,
      placeName: placeInfo.name,
      placeType: placeInfo.type,
      nearbyPOIs: placeInfo.nearbyPOIs
    };
  }
}

// mobile/src/components/ChatScreen.tsx
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, TouchableOpacity, FlatList } from 'react-native';
import { ChatMessage } from '../types';
import { MobileAgentService } from '../services/AgentService';

interface ChatScreenProps {
  agentId: string;
}

export const ChatScreen: React.FC<ChatScreenProps> = ({ agentId }) => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [inputText, setInputText] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isVoiceMode, setIsVoiceMode] = useState(false);
  
  const agentService = new MobileAgentService();
  
  const sendMessage = async (text: string) => {
    if (!text.trim()) return;
    
    const userMessage: ChatMessage = {
      id: Date.now().toString(),
      role: 'user',
      content: text,
      timestamp: new Date()
    };
    
    setMessages(prev => [...prev, userMessage]);
    setInputText('');
    setIsLoading(true);
    
    try {
      const response = await agentService.chatWithAgent(agentId, text);
      setMessages(prev => [...prev, response]);
    } catch (error) {
      console.error('发送消息失败:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  const startVoiceChat = async () => {
    setIsVoiceMode(true);
    try {
      await agentService.startVoiceChat(agentId);
    } catch (error) {
      console.error('语音聊天失败:', error);
    } finally {
      setIsVoiceMode(false);
    }
  };
  
  const renderMessage = ({ item }: { item: ChatMessage }) => (
    <View style={[
      styles.messageContainer,
      item.role === 'user' ? styles.userMessage : styles.agentMessage
    ]}>
      <Text style={styles.messageText}>{item.content}</Text>
      <Text style={styles.messageTime}>
        {item.timestamp.toLocaleTimeString()}
      </Text>
    </View>
  );
  
  return (
    <View style={styles.container}>
      <FlatList
        data={messages}
        renderItem={renderMessage}
        keyExtractor={item => item.id}
        style={styles.messagesList}
      />
      
      <View style={styles.inputContainer}>
        <TextInput
          style={styles.textInput}
          value={inputText}
          onChangeText={setInputText}
          placeholder="输入消息..."
          multiline
        />
        
        <TouchableOpacity
          style={styles.voiceButton}
          onPress={startVoiceChat}
          disabled={isVoiceMode}
        >
          <Text style={styles.buttonText}>
            {isVoiceMode ? '🎤' : '🎙️'}
          </Text>
        </TouchableOpacity>
        
        <TouchableOpacity
          style={styles.sendButton}
          onPress={() => sendMessage(inputText)}
          disabled={isLoading}
        >
          <Text style={styles.buttonText}>发送</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};
```

## 📊 最终完整示例

### 端到端演示流程
```bash
#!/bin/bash
# complete_demo.sh - 完整演示脚本

echo "🎯 OPUS智能体平台完整演示"
echo "=================================="

# 1. 创建示例OPUS智能体
cat > demo_agent.opus << 'EOF'
<identity>
你是智能客服助手小智，专门为电商平台提供24/7客户服务支持。
核心能力：订单查询、退换货处理、商品推荐、问题解答
语气风格：友好热情、专业高效、耐心细致
</identity>

<architecture>
专业知识：[电商业务流程,客户服务标准,商品信息管理,订单处理系统]
核心技能：[订单状态查询,退换货政策解释,商品特性介绍,问题分类处理]
推理引擎：[情感分析,意图识别,问题优先级判断]
外部工具：[订单系统API,商品数据库,物流查询API,支付系统API]
RAG检索：[商品知识库,FAQ数据库,政策文档库]
</architecture>

<Memory>
记忆架构：客户交互历史和偏好分析
动态操作：
[Memory.Store("customer_profile/{user_id}", customer_data)]
[Memory.Retrieve("order_history/{user_id}")]
[Memory.Update("preferences/{user_id}", preference_data)]
[Memory.Locate("similar_issues", context)]
</Memory>

<formats>
[Format.订单查询] = 📦 **订单信息**
- 🔍 **订单号**：{{order_id}}
- 📅 **下单时间**：{{order_date}}
- 💰 **订单金额**：{{amount}}
- 🚚 **物流状态**：{{shipping_status}}
- 📍 **当前位置**：{{current_location}}

[Format.商品推荐] = 🛍️ **为您推荐**
- 📱 **商品名称**：{{product_name}}
- 💵 **价格**：{{price}}
- ⭐ **评分**：{{rating}}
- 🎯 **推荐理由**：{{reason}}

[Format.问题解答] = 💡 **解决方案**
{{solution_steps}}

如需进一步帮助，请联系人工客服：400-123-4567
</formats>

<workflow>
FN 处理客户咨询(user_input):
BEGIN
  意图分析 = 分析用户意图(user_input)
  
  IF 意图分析.type == "订单查询" THEN:
    执行 查询订单信息(意图分析.order_id)
  ELSEIF 意图分析.type == "商品咨询" THEN:
    执行 提供商品信息(意图分析.product_id)
  ELSEIF 意图分析.type == "退换货" THEN:
    执行 处理退换货申请(意图分析.details)
  ELSEIF 意图分析.type == "投诉建议" THEN:
    执行 处理投诉建议(意图分析.content)
  ELSE:
    执行 通用问题解答(user_input)
  END
END

FN 查询订单信息(order_id):
BEGIN
  订单数据 = 调用订单API(order_id)
  物流信息 = 调用物流API(订单数据.tracking_number)
  
  更新客户记忆(客户ID, 订单数据)
  
  输出[Format.订单查询]
END

FN 提供商品信息(product_query):
BEGIN
  商品列表 = RAG检索商品信息(product_query)
  个人偏好 = Memory.Retrieve("preferences/" + 客户ID)
  
  推荐商品 = 个性化排序(商品列表, 个人偏好)
  
  输出[Format.商品推荐]
END

FN 处理退换货申请(申请详情):
BEGIN
  订单验证 = 验证订单有效性(申请详情.订单号)
  政策检查 = 检查退换货政策(申请详情)
  
  IF 政策检查.可以退换 THEN:
    创建退换货申请(申请详情)
    发送确认通知(客户联系方式)
    输出 "✅ 退换货申请已提交，预计3-5个工作日处理完成"
  ELSE:
    输出 "❌ " + 政策检查.拒绝原因
  END
END
</workflow>

<constraints>
**服务标准**：
- 响应时间不超过3秒
- 准确率达到95%以上
- 客户满意度保持在4.5星以上

**行为约束**：
- 保持友好专业的服务态度
- 准确理解客户需求
- 及时提供有效解决方案
- 适时推荐相关商品和服务

**技术约束**：
- 严格保护客户隐私数据
- 确保订单信息准确性
- 遵循公司退换货政策
- 记录所有服务交互
</constraints>
EOF

echo "✅ 创建示例OPUS智能体文件"

# 2. 生成代码工程
echo "🔧 生成代码工程..."
mkdir -p demo_output
python3 opus_converter.py demo_agent.opus --output-dir demo_output --framework fastapi

echo "✅ 代码工程生成完成"

# 3. 构建和部署
echo "🐳 构建Docker镜像..."
cd demo_output
docker build -t opus-demo-agent:latest .

echo "🚀 启动服务..."
docker run -d \
  --name opus-demo \
  -p 8080:8000 \
  -e AGENT_NAME="智能客服小智" \
  -e LOG_LEVEL="INFO" \
  opus-demo-agent:latest

echo "⏳ 等待服务启动..."
sleep 10

# 4. 测试API
echo "🧪 测试API接口..."

# 健康检查
echo "健康检查:"
curl -s http://localhost:8080/health | jq

# 智能体信息
echo -e "\n智能体信息:"
curl -s http://localhost:8080/api/agent/info | jq

# 对话测试
echo -e "\n对话测试:"
curl -s -X POST http://localhost:8080/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "你好，我想查询订单信息"}' | jq

curl -s -X POST http://localhost:8080/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "推荐一些手机给我"}' | jq

# 5. 性能测试
echo -e "\n📊 性能测试..."
echo "并发测试 (10个并发用户，持续30秒):"
ab -n 100 -c 10 -t 30 -T 'application/json' \
  -p <(echo '{"message": "帮我查询订单"}') \
  http://localhost:8080/api/chat

# 6. 监控数据
echo -e "\n📈 监控数据:"
curl -s http://localhost:8080/api/metrics | jq

echo -e "\n✅ 演示完成！"
echo "🌐 Web界面: http://localhost:8080"
echo "📖 API文档: http://localhost:8080/docs"
echo "📊 监控面板: http://localhost:8080/metrics"
echo ""
echo "🔧 管理命令:"
echo "  停止服务: docker stop opus-demo"
echo "  查看日志: docker logs opus-demo"
echo "  重启服务: docker restart opus-demo"
```

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"id": "1", "content": "Analyze existing OPUS documentation and architecture", "status": "completed", "priority": "high"}, {"id": "2", "content": "Design code generation architecture for OPUS-to-code conversion", "status": "completed", "priority": "high"}, {"id": "3", "content": "Create development framework specification", "status": "completed", "priority": "high"}, {"id": "4", "content": "Design intelligent agent product architecture", "status": "completed", "priority": "high"}, {"id": "5", "content": "Create implementation roadmap and examples", "status": "completed", "priority": "medium"}]