# 第7章：外部工具集成

## 7.1 外部工具层概述

### 7.1.1 设计理念

SSAP框架的外部工具层采用"**声明式调用 + 提示词编排**"的设计理念，通过标准化的提示词语法实现对外部工具的调用和控制。

**核心原则**：
- **声明式调用**：在智能体提示词中声明可用的外部工具
- **提示词控制**：通过自然语言描述工具调用逻辑
- **环境分离**：外部工具在独立环境中运行，SSAP只负责调用
- **标准化接口**：统一的工具声明和调用规范

### 7.1.2 架构集成模式

```
SSAP智能体提示词
    ↓
外部工具声明 → 伪代码工作流调用 → 环境执行器
    ↓              ↓               ↓
工具配置描述    CALL_TOOL指令    实际工具运行
格式化规范      参数传递        结果返回
```

**调用流程**：
1. 在`<architecture>`中声明可用外部工具
2. 在`<workflow>`中通过伪代码调用工具
3. 环境执行器解析调用指令并执行
4. 结果通过格式模块标准化返回

## 7.2 工具声明规范

### 7.2.1 基础工具声明

在SSAP框架中，外部工具需要在架构部分明确声明：

```
<architecture>
外部工具配置：
工具类型: MCP协议工具
- 数据库查询工具: database_query
  功能: 执行SQL查询获取数据
  输入格式: {query: "SQL语句", params: 参数对象}
  输出格式: {data: 查询结果, status: 状态信息}

- API调用工具: api_request  
  功能: 调用外部REST API
  输入格式: {endpoint: "API地址", method: "请求方法", data: 请求数据}
  输出格式: {response: API响应, headers: 响应头}

- RAG检索工具: knowledge_search
  功能: 从知识库检索相关信息
  输入格式: {query: "检索查询", filters: 过滤条件}
  输出格式: {results: 检索结果, relevance_score: 相关性分数}

工具约束: 
- 所有工具调用必须通过CALL_TOOL函数
- 工具执行结果必须经过格式模块处理
- 异常情况需要优雅降级处理
</architecture>
```

### 7.2.2 工具能力描述

```
<architecture>
工具能力映射：
分析阶段工具:
- knowledge_search: 获取领域知识和背景信息
- database_query: 查询历史数据和统计信息
- api_request: 获取实时数据和外部信息

处理阶段工具:
- data_processor: 数据清洗和转换
- calculation_engine: 复杂计算和分析
- ai_model_call: 调用专业AI模型

输出阶段工具:
- report_generator: 生成格式化报告
- chart_creator: 创建数据可视化
- notification_sender: 发送通知和提醒
</architecture>
```

## 7.3 工作流中的工具调用

### 7.3.1 基础调用语法

SSAP框架使用统一的调用方式来调用外部工具：

```
<workflow>
FUNCTION 专业分析(用户需求):
BEGIN
  通过[Format.交互格式]显示：🔄 **开始专业分析...**
  
  // 知识检索
  基于[Knowledge.检索策略]，使用[Tool.knowledge_search]获取相关知识：{
    query: 用户需求,
    filters: {domain: 专业领域, type: "理论知识"}
  }
  
  显示：✅ 知识检索完成
  
  // 数据查询  
  IF 需要历史数据 THEN:
    运用[Tool.database_query]查询历史数据：{
      query: "SELECT * FROM data WHERE category = ?",
      params: {category: 分析类别}
    }
    显示：✅ 数据查询完成
  END
  
  // 实时信息获取
  IF 需要最新信息 THEN:
    通过[Tool.api_request]获取实时信息：{
      endpoint: "https://api.example.com/latest",
      method: "GET",
      headers: {Authorization: "Bearer TOKEN"}
    }
    显示：✅ 实时信息获取完成
  END
  
  // 综合分析
  基于[Knowledge.分析方法论]，运用[Skills.数据整合,模式识别]整合所有信息
  通过[Format.分析格式]呈现综合分析结果
  
  显示：✅ **专业分析完成**
  RETURN 格式化的分析结果
END
</workflow>
```

### 7.3.2 条件工具调用

```
<workflow>
FUNCTION 智能检索策略(查询内容, 上下文):
BEGIN
  基于[Knowledge.查询分析方法]，运用[Skill.查询分类]分析查询类型
  
  IF 查询类型 == "概念解释" THEN:
    使用[Tool.knowledge_search]检索概念定义：{
      query: 查询内容,
      type: "概念定义",
      depth: "详细"
    }
  ELSEIF 查询类型 == "数据分析" THEN:
    运用[Skills.SQL生成,查询优化]构建查询语句
    通过[Tool.database_query]获取数据：{
      query: 生成的SQL查询,
      format: "分析报告"
    }
  ELSEIF 查询类型 == "实时状态" THEN:
    基于[Knowledge.API接口规范]，使用[Tool.api_request]获取实时数据：{
      endpoint: 智能确定的API端点,
      method: "GET"
    }
  ELSE:
    // 多工具组合策略
    并行调用[Tools.knowledge_search,database_query]获取多源信息
    运用[Skills.信息融合,结果整合]整合所有结果
  END
  
  通过[Format.结果格式]呈现最终结果
  RETURN 格式化的检索结果
END
</workflow>
```

### 7.3.3 并行工具调用

```
<workflow>
FUNCTION 并行信息收集(研究主题):
BEGIN
  // 并行调用多个工具获取全面信息
  同时使用：
    [Tool.knowledge_search]获取理论知识：{
      query: 研究主题,
      category: "理论基础"
    }
    [Tool.database_query]查询案例数据：{
      query: "SELECT * FROM cases WHERE topic LIKE ?",
      params: {topic: "%" + 研究主题 + "%"}
    }
    [Tool.api_request]获取行业动态：{
      endpoint: "https://industry-api.com/trends",
      params: {keyword: 研究主题}
    }
  
  // 等待所有工具调用完成，然后整合结果
  基于[Knowledge.信息整合理论]，运用[Skills.多源融合,洞察提取]
  综合理论知识、案例数据和行业动态
  
  通过[Format.分析格式]呈现综合分析报告
  RETURN 全面的研究报告
END
</workflow>
```

## 7.4 工具调用的错误处理

### 7.4.1 异常处理机制

```
<workflow>
FUNCTION 安全工具调用(工具名, 参数):
BEGIN
  TRY:
    结果 = CALL_TOOL(工具名, 参数)
    RETURN 结果
  CATCH 工具不可用异常:
    显示: ⚠️ 工具暂时不可用，使用内部能力处理
    备用结果 = 调用内部能力(参数)
    RETURN 备用结果
  CATCH 参数错误异常:
    显示: ⚠️ 参数格式错误，正在修正
    修正参数 = 修正参数格式(参数)
    结果 = CALL_TOOL(工具名, 修正参数)
    RETURN 结果
  CATCH 权限异常:
    显示: ⚠️ 工具访问权限不足
    RETURN 错误信息("权限不足，请联系管理员")
  CATCH 超时异常:
    显示: ⚠️ 工具调用超时，切换备用方案
    备用结果 = 启用备用方案(参数)
    RETURN 备用结果
  END_TRY
END
</workflow>
```

### 7.4.2 降级策略

```
<workflow>
FUNCTION 降级处理策略(原始需求, 失败工具):
BEGIN
  IF 失败工具 == "knowledge_search" THEN:
    // 使用内部知识库
    结果 = 调用内部知识库(原始需求)
    显示: 📚 使用内部知识库提供信息
  ELSEIF 失败工具 == "database_query" THEN:
    // 使用缓存数据或示例数据
    结果 = 获取缓存数据(原始需求)
    显示: 💾 使用历史缓存数据
  ELSEIF 失败工具 == "api_request" THEN:
    // 使用静态信息或内部推理
    结果 = 基于内部能力推理(原始需求)
    显示: 🧠 基于内部能力分析
  END
  
  添加免责说明(结果, "基于有限信息，建议验证")
  RETURN 结果
END
</workflow>
```

## 7.5 MCP协议集成规范

### 7.5.1 MCP工具声明

基于[Model Context Protocol](https://medium.com/@tam.tamanna18/model-context-protocol-mcp-for-retrieval-augmented-generation-rag-and-agentic-ai-6f9b4616d36e)标准，SSAP框架支持标准化的MCP工具集成：

```
<architecture>
MCP工具配置：
协议版本: MCP v1.0

服务器连接:
- 数据库服务器: mcp://localhost:8001/database
  提供工具: [database_query, data_export, schema_info]
  
- API网关服务器: mcp://localhost:8002/gateway
  提供工具: [rest_api_call, webhook_trigger, rate_limit_check]
  
- 知识库服务器: mcp://localhost:8003/knowledge
  提供资源: [document_search, concept_lookup, similarity_search]

工具原语映射:
- Tools → CALL_TOOL函数调用
- Resources → GET_RESOURCE函数调用  
- Prompts → LOAD_PROMPT函数调用

调用约定:
- 所有MCP调用必须包含上下文信息
- 调用结果自动进入格式模块处理
- 支持实时工具发现和注册
</architecture>
```

### 7.5.2 MCP资源访问

```
<workflow>
FUNCTION 获取MCP资源(资源名, 查询参数):
BEGIN
  资源描述 = GET_RESOURCE_INFO(资源名)
  
  IF 资源描述.类型 == "文档库" THEN:
    结果 = GET_RESOURCE(资源名, {
      query: 查询参数.关键词,
      format: "结构化文档",
      max_results: 5
    })
  ELSEIF 资源描述.类型 == "数据流" THEN:
    结果 = GET_RESOURCE(资源名, {
      filters: 查询参数.过滤条件,
      timeframe: 查询参数.时间范围
    })
  END
  
  格式化结果 = 应用格式模块(结果, 资源描述.输出格式)
  RETURN 格式化结果
END
</workflow>
```

### 7.5.3 外部工具简化调用

基于[MCP工具架构](https://modelcontextprotocol.io/docs/concepts/tools)，SSAP框架中的外部工具调用采用简化的名称和指令方式：

#### 基础工具调用语法

```
<workflow>
// 文档检索工具
技术文档 = CALL_TOOL("search_docs", "React hooks 最佳实践")
库信息 = CALL_TOOL("get_library", "Next.js")

// 数据查询工具  
销售数据 = CALL_TOOL("query_database", "SELECT * FROM sales WHERE date > '2024-01-01'")
用户信息 = CALL_TOOL("get_user", "user123")

// API调用工具
天气信息 = CALL_TOOL("call_api", "GET weather/current?city=北京")
发送消息 = CALL_TOOL("send_notification", "任务完成通知")

// 文件操作工具
文件内容 = CALL_TOOL("read_file", "config.json")
保存结果 = CALL_TOOL("write_file", "report.pdf", 报告数据)
</workflow>
```

#### 简化工作流示例

```
<workflow>
FUNCTION 技术咨询(问题描述):
BEGIN
  // 直接调用工具，无需复杂配置
  相关文档 = CALL_TOOL("search_docs", 问题描述)
  代码示例 = CALL_TOOL("get_examples", 问题描述)
  
  IF 需要最新信息 THEN:
    实时数据 = CALL_TOOL("fetch_latest", 问题描述)
  END
  
  解决方案 = 生成技术方案(相关文档, 代码示例, 实时数据)
  RETURN 解决方案
END
</workflow>
```

#### 实际应用案例：技术选型助手

```
<identity>
你是"技术选型顾问"，专精现代软件开发技术栈选择，具备Context7 MCP增强的技术检索能力。

身份约束：始终保持技术中立，基于项目实际需求推荐最适合的技术方案。

应用场景：为开发团队提供基于最新文档和最佳实践的技术选型建议
</identity>

<architecture>
专业知识：软件架构设计、技术栈评估、性能优化、开发效率分析

核心技能：需求分析、技术对比、风险评估、实施规划

推理引擎：多维度技术评估、兼容性分析、成本效益计算

格式模块系统：
分析格式模块 = {
  📋 **需求分析**
  - 项目规模：{规模等级}
  - 技术要求：{核心需求列表}
  - 约束条件：{限制因素}
  
  🔍 **技术调研**
  - 候选技术：{技术选项对比表}
  - 生态成熟度：{生态评估}
  - 学习曲线：{难度分析}
}

结果格式模块 = {
  ⭐ **推荐方案**
  - 核心技术栈：{主要技术组合}
  - 选择理由：{决策依据}
  - 实施路径：{分阶段计划}
  
  📊 **对比分析**
  - 方案对比：{多方案比较表}
  - 风险评估：{潜在风险和缓解措施}
  - ROI分析：{投入产出评估}
  
  💡 **实施建议**
  - 快速开始：{MVP实施步骤}
  - 最佳实践：{推荐做法}
  - 避坑指南：{常见问题预防}
}

交互格式模块 = {
  🎯 **确认需求**：需要更多项目细节时的询问格式
  ⚠️ **风险提醒**：发现潜在问题时的警告格式  
  ✅ **方案确认**：等待用户确认技术选择
}

Context7 MCP工具配置：
- library_search: 搜索最新技术文档和比较信息
- get_docs: 获取详细的技术规范和使用指南
- semantic_search: 语义化检索相关技术解决方案
- version_check: 检查技术栈兼容性和版本依赖
- code_examples: 获取实际代码示例和最佳实践

记忆管理：跟踪项目背景、技术偏好、团队能力评估、历史选型经验
</architecture>

<workflow>
FUNCTION 技术选型咨询(项目需求):
BEGIN
  状态显示 = 检查状态需求(项目需求)
  IF 状态显示 THEN: 显示: 🔄 **开始技术选型分析...**
  
  // 需求分析
  项目分析 = 深度分析项目需求(项目需求)
  调用格式模块(分析格式模块, 项目分析)
  
  // Context7技术检索
  IF 状态显示 THEN: 显示: 🔍 **启动Context7技术检索...**
  
  候选技术 = CALL_TOOL("library_search", {
    query: 项目分析.核心需求,
    domain: 项目分析.技术领域,
    criteria: ["性能", "易用性", "生态", "维护性"]
  })
  
  // 获取详细技术文档
  技术详情 = []
  FOR 每个候选技术 IN 候选技术.top_5:
    技术文档 = CALL_TOOL("get_docs", {
      library_id: 候选技术.id,
      sections: ["概述", "性能基准", "学习资源", "社区支持"],
      context: 项目分析.使用场景
    })
    技术详情.添加(技术文档)
  END_FOR
  
  // 兼容性和依赖检查
  IF 项目分析.现有技术栈 THEN:
    兼容性分析 = CALL_TOOL("version_check", {
      proposed_stack: 候选技术.top_3,
      existing_stack: 项目分析.现有技术栈,
      migration_complexity: true
    })
  END
  
  // 语义化解决方案检索
  相似方案 = CALL_TOOL("semantic_search", {
    query: 项目需求 + " 技术选型案例",
    corpus: "documentation_corpus", 
    filters: {
      project_scale: 项目分析.项目规模,
      industry: 项目分析.行业领域
    }
  })
  
  // 获取实践示例
  最佳实践 = GET_RESOURCE("code_examples", {
    technologies: 候选技术.top_3.names,
    use_cases: 项目分析.核心功能,
    complexity: 项目分析.技术复杂度
  })
  
  IF 状态显示 THEN: 显示: ✅ **技术调研完成**
  
  // 综合评估和推荐
  技术评估 = 综合技术评估(技术详情, 兼容性分析, 相似方案, 最佳实践)
  推荐方案 = 生成技术选型建议(技术评估, 项目分析)
  
  调用格式模块(结果格式模块, 推荐方案)
  
  // 确认环节
  调用格式模块(交互格式模块, "方案确认")
  显示: 💬 **需要针对特定技术进行深入分析吗？**
  
  IF 状态显示 THEN: 显示: ✅ **技术选型咨询完成**
  RETURN 推荐方案
END
</workflow>

<constraints>
**输出标准**：
- 必须基于Context7 MCP获取的最新技术文档
- 所有技术建议必须包含具体的实施步骤
- 风险评估必须客观且具有可操作性

**约束规范**：
- 禁止推荐过时或不维护的技术
- 禁止忽视项目实际约束条件
- 必须提供多个备选方案
- 必须基于实际文档和代码示例给出建议

**交互说明**：
添加"显示状态"可查看Context7检索过程，"深入分析 [技术名]"获取特定技术的详细评估
</constraints>
```

这个Context7 MCP示例展示了：

1. **完整的MCP集成配置**：基于[官方MCP架构](https://modelcontextprotocol.io/introduction)
2. **实际的工具调用流程**：使用SSAP的伪代码语法
3. **具体的应用场景**：技术选型助手智能体
4. **标准化的配置方法**：参考[MCP示例服务器](https://modelcontextprotocol.io/examples)

通过Context7 MCP集成，SSAP智能体可以获得实时的技术文档检索能力，大大增强了技术咨询和开发辅助的专业性。

## 7.6 RAG系统集成

### 7.6.1 知识检索

```
<workflow>
FUNCTION 知识检索(查询):
BEGIN
  // 简化的多路径检索
  向量结果 = CALL_TOOL("search_vector", 查询)
  精确结果 = CALL_TOOL("search_exact", 查询)
  实时结果 = CALL_TOOL("search_realtime", 查询)
  
  最终结果 = 融合排序(向量结果, 精确结果, 实时结果)
  RETURN 最终结果
END
</workflow>
```

### 7.6.2 上下文检索

```
<workflow>
FUNCTION 上下文检索(查询, 历史):
BEGIN
  上下文 = 提取上下文(历史)
  结果 = CALL_TOOL("search_context", 查询 + 上下文)
  
  RETURN 结果
END
</workflow>
```

## 7.7 工具编排模式

### 7.7.1 串行工具链

```
<workflow>
FUNCTION 数据处理流程(原始数据):
BEGIN
  // 简化的串行调用
  清洗数据 = CALL_TOOL("clean_data", 原始数据)
  分析结果 = CALL_TOOL("analyze_data", 清洗数据)
  图表 = CALL_TOOL("create_chart", 分析结果)
  报告 = CALL_TOOL("generate_report", 图表)
  
  RETURN 报告
END
</workflow>
```

### 7.7.2 条件分支调用

```
<workflow>
FUNCTION 智能分析(需求):
BEGIN
  IF 需求包含"财务" THEN:
    结果 = CALL_TOOL("financial_analysis", 需求)
  ELSEIF 需求包含"市场" THEN:
    结果 = CALL_TOOL("market_analysis", 需求)
  ELSEIF 需求包含"技术" THEN:
    结果 = CALL_TOOL("technical_analysis", 需求)
  END
  
  RETURN 结果
END
</workflow>
```

### 7.7.3 循环优化模式

```
<workflow>
FUNCTION 迭代优化(初始方案):
BEGIN
  当前方案 = 初始方案
  FOR 次数 = 1 TO 5:
    评估 = CALL_TOOL("evaluate", 当前方案)
    IF 评估 >= 目标分数 THEN BREAK
    
    当前方案 = CALL_TOOL("optimize", 当前方案)
  END_FOR
  
  RETURN 当前方案
END
</workflow>
```

## 7.8 实际应用案例

### 7.8.1 数据分析智能体

```
<workflow>
FUNCTION 业务分析(需求):
BEGIN
  数据 = CALL_TOOL("query_data", 需求)
  图表 = CALL_TOOL("create_chart", 数据)  
  报告 = CALL_TOOL("generate_report", 数据 + 图表)
  
  RETURN 报告
END
</workflow>
```

### 7.8.2 客户服务智能体

```
<workflow>
FUNCTION 客户咨询(问题, 客户ID):
BEGIN
  档案 = CALL_TOOL("get_customer", 客户ID)
  
  IF 问题包含"订单" THEN:
    信息 = CALL_TOOL("check_order", 客户ID)
  ELSEIF 问题包含"退款" THEN:
    STOP_AND_WAIT  // 需要确认
    信息 = CALL_TOOL("process_refund", 客户ID)
  ELSE:
    信息 = CALL_TOOL("search_knowledge", 问题)
  END
  
  RETURN 生成回复(档案, 信息)
END
</workflow>
```

### 7.8.3 开发助手智能体

```
<workflow>
FUNCTION 开发协助(任务):
BEGIN
  代码 = CALL_TOOL("search_code", 任务)
  文档 = CALL_TOOL("search_docs", 任务)
  方案 = 生成解决方案(代码, 文档)
  
  IF 需要测试 THEN:
    测试 = CALL_TOOL("run_tests", 方案)
  END
  
  RETURN 方案
END
</workflow>
```

## 7.9 最佳实践

### 7.9.1 简化原则

1. **直接调用** - 使用工具名称和简单指令
2. **伪代码控制** - 通过IF/FOR等逻辑编排工具
3. **必要确认** - 敏感操作使用STOP_AND_WAIT

### 7.9.2 使用要点

- 工具已启用，直接通过名称调用
- 保持调用逻辑简洁清晰  
- 重要操作前先确认用户意图

通过简化的外部工具调用，SSAP框架实现了高效的工具集成能力。 